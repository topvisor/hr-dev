# Тестовые задания по PHP

**Важное замечание**: написание кода должно выполняться самостоятельно, без использования искусственного интеллекта (
например, Grok, ChatGPT) или других автоматизированных инструментов. Цель заданий — оценить ваши личные навыки
программирования, логического мышления и понимания концепций ООП.

Этот документ содержит тестовые задания по PHP, предназначенные для оценки знаний алгоритмов, логического мышления и
концепций объектно-ориентированного программирования (ООП). Задания разделены на три уровня сложности: начальный,
средний и продвинутый.

## Уровень 1: Начальный (Basic)

### Задача: Проверка палиндрома

Напишите функцию, которая проверяет, является ли строка палиндромом (читается одинаково слева направо и справа налево,
игнорируя пробелы, знаки препинания и регистр).

**Требования:**

- Функция должна принимать строку в качестве входного параметра.
- Игнорировать пробелы, знаки препинания и учитывать регистр (например, "А роза упала на лапу Азора" — это палиндром).
- Вернуть `true`, если строка — палиндром, и `false` в противном случае.

**Пример:**

```php
echo isPalindrome("А роза упала на лапу Азора"); // true
echo isPalindrome("привет"); // false
```

**Ожидаемое решение:**

```php
function isPalindrome(string $str): bool {
    // ...
}
```

## Уровень 2: Средний (Intermediate)

### Задача: Реализация стека с ограничением по размеру

Создайте класс `LimitedStack`, реализующий стек с фиксированным размером. Стек должен поддерживать операции `push`,
`pop` и `peek`, а также проверять, пуст ли стек или переполнен.

**Требования:**

- Класс должен принимать максимальный размер стека при создании.
- Метод `push` добавляет элемент, если стек не полон, иначе выбрасывает исключение.
- Метод `pop` возвращает и удаляет верхний элемент, если стек не пуст, иначе выбрасывает исключение.
- Метод `peek` возвращает верхний элемент без удаления, если стек не пуст.
- Метод `isEmpty` возвращает `true`, если стек пуст.
- Метод `isFull` возвращает `true`, если стек полон.

**Пример:**

```php
$stack = new LimitedStack(3);
$stack->push(1); // [1]
$stack->push(2); // [1, 2]
$stack->push(3); // [1, 2, 3]
$stack->push(4); // Exception: Stack is full
echo $stack->pop(); // 3
echo $stack->peek(); // 2
```

**Ожидаемое решение:**

```php
class LimitedStack {
    private $items = [];
    private $maxSize;

    public function __construct(int $maxSize) {
        // ...
    }
    
    // ...
}
```

## Уровень 3: Продвинутый (Advanced)

### Задача: Построение и обход бинарного дерева
Создайте классы для реализации бинарного дерева поиска (BST), где каждое значение автоматически размещается в дереве согласно правилу: значения меньше текущего узла помещаются в левое поддерево, а значения больше или равные — в правое поддерево. Реализуйте методы вставки узла, обхода дерева в порядке "in-order" (левый узел, корень, правый узел) и поиска минимального значения.

**Требования:**
- Реализовать класс `Node` для представления узла дерева (значение, левый и правый потомки).
- Реализовать класс `BinarySearchTree` с методами:
  - `insert($value)` — вставка нового значения с автоматическим определением места в дереве.
  - `inOrder()` — возвращает массив значений при обходе in-order.
  - `findMin()` — возвращает минимальное значение в дереве или `null`, если дерево пусто.
- Использовать ООП-принципы (инкапсуляция, четкое разделение ответственности).
- Обеспечить обработку случаев, когда дерево пусто.

**Пример:**

```php
$bst = new BinarySearchTree();
$bst->insert(10); // Корень дерева
$bst->insert(5);  // Помещается в левое поддерево (5 < 10)
$bst->insert(15); // Помещается в правое поддерево (15 > 10)
$bst->insert(3);  // Помещается в левое поддерево узла 5 (3 < 5)

/*
Получается следующее дерево:
       10
      /  \
     5   15
    /
   3
*/

print_r($bst->inOrder()); // [3, 5, 10, 15] — обход in-order: левое поддерево, корень, правое поддерево
echo $bst->findMin(); // 3 — минимальное значение в дереве
```

**Ожидаемое решение:**
```php
class Node {
    public $value;
    public $left = null;
    public $right = null;

    public function __construct($value) {
        $this->value = $value;
    }
}

class BinarySearchTree {
    private $root;

    public function __construct() {
        $this->root = null;
    }

    public function insert($value): void {
        $newNode = new Node($value);
        // ...
    }

    // ...

    public function inOrder(): array {
        // ...
    }

    public function findMin() {
        // ...
    }
}
```
